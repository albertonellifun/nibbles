<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>Nibbles/Snake clone</title>
<style>
  body {
    margin: 0;
	padding: 0;
	background: #000;
    height: 100vh;
	width: 100vw;
    display: flex;
	flex-direction: row;
	justify-content: center;
	align-items: stretch;
    gap: 10px;
    overflow: hidden;	
  }

  h1 {
    margin: 0;
	padding: 10px;
	background: #000;
    color: #fff;
    writing-mode: vertical-lr;
    text-orientation: upright;
    font-family: sans-serif;
    font-size: clamp(10px, 2.5vh, 28px);
    border: 4px solid #3c3;
	height: 94vh;
  }

  #game-container {
    margin: 0;
	padding: 0;
	background: #000;
    display: flex;
	flex-direction: row;
    flex-wrap: nowrap;
    gap: 10px;
	justify-content: center;
    align-items: stretch;
  }
  
  #game {
    margin: 0;
	padding: 10px;
	background: #000;
    border: 4px solid #3c3;
    aspect-ratio: 1 / 1;
	height: 94vh;
	max-width: 70%;
  }

  #stats {
    margin: 0;
	padding: 10px;
	background: #000;
    border: 4px solid #3c3;
    aspect-ratio: 140 / 500;
	height: 94vh;
	max-width: 20%;
  }
</style>
</head>
<body>
  <h1 onclick="reset()">NIBBLES / SNAKE CLONE</h1>
  <div id="game-container">
    <canvas id="game"  width="500" height="500"></canvas>
    <canvas id="stats" width="140" height="500"></canvas>
  </div>
  
  <audio id="eatSound" preload="auto">
	<source src="./res/eat.wav" type="audio/mpeg">
  </audio>
  <audio id="turn1Sound" preload="auto">
	<source src="./res/turn1.wav" type="audio/mpeg">
  </audio>
  <audio id="turn2Sound" preload="auto">
	<source src="./res/turn2.wav" type="audio/mpeg">
  </audio>
  <audio id="turn3Sound" preload="auto">
	<source src="./res/turn3.wav" type="audio/mpeg">
  </audio>
  <audio id="turn4Sound" preload="auto">
	<source src="./res/turn4.wav" type="audio/mpeg">
  </audio>
  <audio id="dieSound" preload="auto">
	<source src="./res/die.wav" type="audio/mpeg">
  </audio>
  <audio id="catSound" preload="auto">
  	<source src="./res/cat.wav" type="audio/mpeg">
  </audio>
<script>
const gameCanvas = document.getElementById('game');
const gameCtx = gameCanvas.getContext('2d');
const cols = 25;
const rows = 25;
const cell = Math.min(gameCanvas.width / cols, gameCanvas.height / rows);//20
const padding = 1;//1 cella vuota intorno

const statsCanvas = document.getElementById('stats');
const statsCtx = statsCanvas.getContext('2d');
const statsCols = 7;
const statsRows = 25;
let statsArray = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
let redrawStats = true;

let bananaGrow = 0;//quando settato il serpente creeesce
let poisonEffect = 0;//quando settato il serpente e' stupefacente :)
let skeletorFactor = 1;//fattore di magrezza, default = 1
let burgerFactor = 1;//fattore di ciccionosita' dei segmenti
let hasCrown = false;//chi e' lo re? ATTILA!
let godmodeEffect = 0;//quando settato il serpente attraversa i muri

let snake = [ { x: (cols / 3) | 0, 
				y: (rows / 3) | 0, 
				oldX: ((cols / 3) | 0) - 1, 
				oldY: (rows / 3) | 0 } ];

//problema della direzione, aggiornata al tick, ma con coda...
let dir = { x: 1, y: 0 };
let nextDir = dir;//aggiorno al tick, non immediatamente
let inputQueue = [];


let apples = [ { x: (cols / 4) | 0, 
				 y: (rows / 4) | 0, 
				 type: 0 } ];//serpente cresce/si droga/muore
let alive = true;
let snakeMinLength = 4;
let applesEaten = [];

let message = [];

let currentSnakePattern = 0;
const COLORS = {
	snakeLight0:'#8f5', snakeDark0:'#4c4', snakeBorder0:'#af7', //green
	snakeLight1:'#f85', snakeDark1:'#c44', snakeBorder1:'#fa7', //red
	snakeLight2:'#85f', snakeDark2:'#44c', snakeBorder2:'#a7f', //violet
	snakeLight3:'#860', snakeDark3:'#640', snakeBorder3:'#a80', //brown
	snakeLight4:'#ccc', snakeDark4:'#aaa', snakeBorder4:'#fff', //skeletor
	snakeLight5:'#f7b', snakeDark5:'#a37', snakeBorder5:'#803', //ciccione
	snakeLight6:'#ff5', snakeDark6:'#aa0', snakeBorder6:'#880', //godmode
	
	snakeLight7:'#57f', snakeDark7:'#35d', snakeBorder7:'#14a', //google
	snakeLight8:'#ba9', snakeDark8:'#322', snakeBorder8:'#000', //rocky graffietto
	
	backgroundLight0:'#420', backgroundDark0:'#200', backgroundBorder0:'#640', //brown
	backgroundLight1:'#024', backgroundDark1:'#002', backgroundBorder1:'#046', //blue
	backgroundLight2:'#240', backgroundDark2:'#020', backgroundBorder2:'#460', //green
	backgroundLight3:'#444', backgroundDark3:'#222', backgroundBorder3:'#666', //gray
	backgroundLight4:'#620', backgroundDark4:'#000', backgroundBorder4:'#b60', //orange
	backgroundLight5:'#024', backgroundDark5:'#400', backgroundBorder5:'#f7b', //pink
	backgroundLight6:'#024', backgroundDark6:'#002', backgroundBorder6:'#009', //blue
	
	backgroundLight7:'#ad5', backgroundDark7:'#9c4', backgroundBorder7:'#cf7', //google
	backgroundLight8:'#876', backgroundDark8:'#654', backgroundBorder8:'#5cf', //rocky graffietto
	
	brown:'#640',
	red:'#f00',
	white:'#fff',				 
	black:'#000',
	gray:'#666', lightGray:'#9aa', medGray:'#999', darkGray:'#222',
	green:'#6f6', medGreen: '#3a3', darkGreen: '#181',
	appleRedLight:'#f66', appleRedMed:'#c00', appleRedDark:'#600',
	};

//pattern squame
function createSnakePattern(ctx) {
  const patternCanvas = document.createElement('canvas');
  const pctx = patternCanvas.getContext('2d');
  const size = 12; // dimensione base delle squame
  patternCanvas.width = size;
  patternCanvas.height = size;
  
  //sfondo
  pctx.fillStyle = COLORS['snakeDark' + currentSnakePattern];
  pctx.fillRect(0, 0, size, size);

  //squame
  pctx.fillStyle = COLORS['snakeLight' + currentSnakePattern];
  for (let y = 0; y < size; y += 6) {
    for (let x = (y/6)%2===0 ? 0 : 6; x < size; x += size) {
      pctx.beginPath();
      pctx.arc(x+3, y+3, 3, 0, Math.PI*2);
      pctx.fill();
    }
  }
  return ctx.createPattern(patternCanvas, 'repeat');
}

//pattern rombi
function createSnakePatternSquare(ctx) {
  const patternCanvas = document.createElement("canvas");
  const pctx = patternCanvas.getContext("2d");
  const size = 12; // dimensione base delle squame
  patternCanvas.width = size;
  patternCanvas.height = size;

  //sfondo
  pctx.fillStyle = COLORS['snakeLight' + currentSnakePattern];
  pctx.fillRect(0, 0, size, size);

  //squama romboidale
  pctx.beginPath();
  pctx.moveTo(size / 2, 0);
  pctx.lineTo(size, size / 2);
  pctx.lineTo(size / 2, size);
  pctx.lineTo(0, size / 2);
  pctx.closePath();
  pctx.fillStyle = COLORS['snakeDark' + currentSnakePattern];
  pctx.fill();

  //bordo
  pctx.strokeStyle = COLORS['snakeBorder' + currentSnakePattern];
  pctx.lineWidth = 1;
  pctx.stroke();

  return ctx.createPattern(patternCanvas, "repeat");
}

//pattern palle
function createSnakePatternBalls(ctx) {
  const patternCanvas = document.createElement("canvas");
  const pctx = patternCanvas.getContext("2d");
  const size = 12; // dimensione base delle squame
  patternCanvas.width = size;
  patternCanvas.height = size;

  //sfondo
  pctx.fillStyle = COLORS["snakeLight" + currentSnakePattern];
  pctx.fillRect(0, 0, size, size);

  //palla
  pctx.beginPath();
  pctx.arc(size / 2, size / 2, size / 2, 0, 2 * Math.PI);
  pctx.fillStyle = COLORS["snakeDark" + currentSnakePattern];
  pctx.fill();

  //bordo
  pctx.strokeStyle = COLORS["snakeBorder" + currentSnakePattern];
  pctx.lineWidth = 1;
  pctx.stroke();

  return ctx.createPattern(patternCanvas, "repeat");
}


let snakePattern = [];
initSnakePatterns();

function initSnakePatterns(type) {
  snakePattern = []
  for (let i = 0; i < 9; i++) {
    currentSnakePattern = i;
	snakePattern.push(
		type === 2 ? createSnakePatternBalls(gameCtx) :
		type === 1 ? createSnakePatternSquare(gameCtx) :
		createSnakePattern(gameCtx)
	);
  }
  currentSnakePattern = 0;
}




//corpo
function drawSegment(ctx, curr, prev, isLast) {
  const px = curr.x * cell + cell / 2;
  const py = curr.y * cell + cell / 2;
  
  ctx.save();
  ctx.fillStyle = snakePattern[currentSnakePattern];
  ctx.strokeStyle = COLORS['snakeBorder'+currentSnakePattern];
  
  if (!isLast) {
    //segmento normale
    ctx.beginPath();
	
    let eatenIdx = burgerFactor !== 1 ? -1 : applesEaten.findIndex(elem => Math.abs(elem.x - curr.x) < 0.51 && Math.abs(elem.y - curr.y) < 0.51);
	if (eatenIdx !== -1) {
	  let maxAge = 3000;
	  let age = Date.now() - applesEaten[eatenIdx].when;//delta in ms
	  if (age > maxAge) {
	    applesEaten.splice(eatenIdx, 1);
		ctx.arc(px, py, burgerFactor * cell / 2 - 2, 0, Math.PI * 2);
      }
	  else {
  	    ctx.arc(px, py, (1.5 - age/(maxAge * 1.5)) * cell / 2 - 2, 0, Math.PI * 2);
	  }
	}
	else {
      ctx.arc(px, py, burgerFactor * cell / 2 - 2, 0, Math.PI * 2);
	}
    ctx.fill();
    ctx.stroke();
  } else {
    //ultimo segmento == coda
    const steps = 4;//mini-cerchi a stringere
    const radiusStart = cell / 2.1;

    //direzione verso il segmento precedente
    const dx = curr.x - prev.x;
    const dy = curr.y - prev.y;

    let cx = px;
    let cy = py;

    for (let i = 0; i < steps; i++) {
      const t = i / steps;
      const radius = radiusStart * (1 - t * 0.7);//raggio decrescente

      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();

      //spostamento verso il segmento precedente
      cx += dx * (cell / steps);
      cy += dy * (cell / steps);
    }
  }
  
  //raccordo col segmento precedente per evitare spazi
  const nx = prev.x * cell + cell / 2;
  const ny = prev.y * cell + cell / 2;
  //fix godmode -> se passo attraverso i muri, non devo disegnare i collegamenti
  if (Math.abs(curr.x - prev.x) < 3 && Math.abs(curr.y - prev.y) < 3) {
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(nx, ny);
    ctx.lineWidth = (cell * skeletorFactor) - 2;
    ctx.strokeStyle = snakePattern[currentSnakePattern];
    ctx.stroke();
  }
  
  ctx.restore();
}


//the best siamese cat in the world
function drawRockyGraffietto(ctx, curr) {
  const cx = curr.x * cell + cell / 2;
  const cy = curr.y * cell + cell / 2;
  const r = 4 * cell / 5;
  ctx.save();
  
  // Colori tipici del siamese
  const faceColor = "#ba9";  // beige chiaro
  const maskColor = "#322";  // marrone scuro (muso e orecchie)
  const eyeColor = "#5cf";   // azzurro
  
  //gradiente faccia radiale centrato nella testa
  const headGrad = ctx.createRadialGradient(cx, cy, r * 0.1, cx, cy, r);
  headGrad.addColorStop(0, "#322");  // centro: leggermente pi√π scuro
  headGrad.addColorStop(1, "#ba9");  // bordi: pi√π chiari
  //gradiente muso radiale centrato
  const maskGrad = ctx.createRadialGradient(cx, cy + r / 10, //centro
											r * 0.05,        //raggio interno (dove inizia il nero)
											cx, cy + r / 10,
											r * 0.75         // raggio esterno (copre tutto il muso)
  );

  // Colori del gradiente
  maskGrad.addColorStop(0, "#222"); // marrone scuro
  maskGrad.addColorStop(1, "#322");   // marrone pi√π chiaro ai lati

  //testa
  ctx.beginPath();
  ctx.ellipse(cx, cy, r, 3 * r / 5, 0, 0, Math.PI * 2);//schiacciata
  ctx.closePath();
  ctx.fillStyle = headGrad;//faceColor;
  ctx.fill();
  
  //muso
  ctx.beginPath();
  ctx.ellipse(cx, cy + r / 10, 3 * r / 4, 2 * r / 5, 0, 0, Math.PI * 2);
  ctx.fillStyle = maskGrad;//maskColor;
  ctx.fill();
  
  //orecchio sx
  ctx.beginPath();
  ctx.moveTo(cx - 45 * r / 50, cy - 10 * r / 50);
  ctx.lineTo(cx - 50 * r / 50, cy - 50 * r / 50);
  ctx.lineTo(cx - 15 * r / 50, cy - 25 * r / 50);
  ctx.closePath();
  //orecchio dx
  ctx.moveTo(cx + 45 * r / 50, cy - 10 * r / 50);
  ctx.lineTo(cx + 50 * r / 50, cy - 50 * r / 50);
  ctx.lineTo(cx + 15 * r / 50, cy - 25 * r / 50);
  ctx.closePath();
  ctx.fillStyle = maskColor;
  ctx.fill();
  
  //occhi
  ctx.beginPath();
  ctx.ellipse(cx - 30 * r / 100, cy -5 * r / 100, 14 * r / 100, 14 * r / 100, 0, 0, Math.PI * 2);
  ctx.ellipse(cx + 30 * r / 100, cy -5 * r / 100, 14 * r / 100, 14 * r / 100, 0, 0, Math.PI * 2);
  ctx.fillStyle = eyeColor;
  ctx.fill();
  
  //pupille
  ctx.beginPath();
  ctx.ellipse(cx - 30 * r / 100, cy - 5 * r / 100, 3 * r / 100, 8 * r / 100, 0, 0, Math.PI * 2);
  ctx.ellipse(cx + 30 * r / 100, cy - 5 * r / 100, 3 * r / 100, 8 * r / 100, 0, 0, Math.PI * 2);
  ctx.fillStyle = COLORS.black;
  ctx.fill();
  
  //naso
  ctx.beginPath();
  ctx.moveTo(cx - 10 * r / 100, cy + 15 * r / 100);
  ctx.lineTo(cx + 0 * r / 100, cy + 22 * r / 100);
  ctx.lineTo(cx + 10 * r / 100, cy + 15 * r / 100);
  ctx.closePath();
  ctx.fillStyle = COLORS.black;
  ctx.fill();
  
  //bocca
  ctx.strokeStyle = faceColor;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(cx + 0, cy + 22 * r / 100);
  ctx.lineTo(cx + 0, cy + 30 * r / 100);
  
  ctx.moveTo(cx + 0, cy + 30 * r / 100);
  ctx.quadraticCurveTo(cx - 5 * r / 100, cy + 35 * r / 100, cx - 10 * r / 100, cy + 30 * r / 100);
  
  ctx.moveTo(cx + 0, cy + 28 * r / 100);
  ctx.quadraticCurveTo(cx + 5 * r / 100, cy + 35 * r / 100, cx + 10 * r / 100, cy + 30 * r / 100);
  ctx.stroke();

  // --- Baffi ---
  ctx.strokeStyle = COLORS.lightGray;
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  // sinistra
  ctx.moveTo(cx - 10 * r / 100, cy + 20 * r / 100);
  ctx.lineTo(cx - 60 * r / 100, cy + 15 * r / 100);
  ctx.moveTo(cx - 10 * r / 100, cy + 24 * r / 100);
  ctx.lineTo(cx - 60 * r / 100, cy + 25 * r / 100);
  ctx.moveTo(cx - 10 * r / 100, cy + 28 * r / 100);
  ctx.lineTo(cx - 60 * r / 100, cy + 35 * r / 100);
  // destra
  ctx.moveTo(cx + 10 * r / 100, cy + 20 * r / 100);
  ctx.lineTo(cx + 60 * r / 100, cy + 15 * r / 100);
  ctx.moveTo(cx + 10 * r / 100, cy + 24 * r / 100);
  ctx.lineTo(cx + 60 * r / 100, cy + 25 * r / 100);
  ctx.moveTo(cx + 10 * r / 100, cy + 28 * r / 100);
  ctx.lineTo(cx + 60 * r / 100, cy + 35 * r / 100);
  ctx.stroke();

  ctx.restore();
}



//testa
function drawHead(ctx, curr, dir, neck) {
  const cx = curr.x * cell + cell / 2;
  const cy = curr.y * cell + cell / 2;
  
  //testa
  ctx.fillStyle = COLORS['snakeDark'+currentSnakePattern];//COLORS.green;
  ctx.beginPath();
  ctx.arc(cx, cy, cell / 2.2, 0, Math.PI * 2);
  ctx.fill();
  
  //collo 
  if(neck) {
    const neckX = neck.x * cell + cell / 2;
    const neckY = neck.y * cell + cell / 2;
    ctx.beginPath();
    ctx.arc(neckX, neckY, cell / 2.2, 0, Math.PI * 2);
    ctx.fill();
  }

  //occhi
  const eyeOffset = 2 * cell / 5;
  const eyeSize = cell / 3;
  let ex1, ey1, ex2, ey2;
  if (dir.y === 1) {
    ex1 = cx - eyeOffset / 2; ey1 = cy - eyeOffset;
    ex2 = cx + eyeOffset / 2; ey2 = cy - eyeOffset;
  } else if (dir.y === -1) {
    ex1 = cx - eyeOffset / 2; ey1 = cy + eyeOffset;
    ex2 = cx + eyeOffset / 2; ey2 = cy + eyeOffset;
  } else if (dir.x === -1) {
    ex1 = cx + eyeOffset; ey1 = cy - eyeOffset / 2;
    ex2 = cx + eyeOffset; ey2 = cy + eyeOffset / 2;
  } else {
    ex1 = cx - eyeOffset; ey1 = cy - eyeOffset / 2;
    ex2 = cx - eyeOffset; ey2 = cy + eyeOffset / 2;
  }
  
  //occhio
  ctx.fillStyle = COLORS.white;
  ctx.beginPath(); ctx.arc(ex1, ey1, eyeSize, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(ex2, ey2, eyeSize, 0, Math.PI * 2); ctx.fill();
  
  //pupille
  if (snakeEyesEnabled) {
    ctx.strokeStyle = COLORS.black;
    ctx.lineCap = "round"; // bordi arrotondati
    ctx.lineWidth = eyeSize / 2.5; // spessore = diametro della pupilla
    
	if (dir.y) {
	  ctx.beginPath();
      ctx.moveTo(ex1, ey1 - eyeSize / 3);
      ctx.lineTo(ex1, ey1 + eyeSize / 3);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(ex2, ey2 - eyeSize / 3);
      ctx.lineTo(ex2, ey2 + eyeSize / 3);
      ctx.stroke();
	} else {
	  ctx.beginPath();
      ctx.moveTo(ex1 - eyeSize / 3, ey1);
      ctx.lineTo(ex1 + eyeSize / 3, ey1);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(ex2 - eyeSize / 3, ey2);
      ctx.lineTo(ex2 + eyeSize / 3, ey2);
      ctx.stroke();
	}
  } else {
    ctx.fillStyle = COLORS.black;
    ctx.beginPath(); ctx.arc(ex1, ey1, eyeSize / 2.5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(ex2, ey2, eyeSize / 2.5, 0, Math.PI * 2); ctx.fill();
  }
  

  //palpebre
  if (eyelidEnabled) {
	  ctx.fillStyle = COLORS['snakeLight' + currentSnakePattern];	  
	  ctx.beginPath();
	  let modulo = ((curr.x | 0) + (curr.y | 0)) % 3;
	  let spostamentoSx = modulo === 0 ? 3 : modulo === 1 ? 2 : 1;
	  let spostamentoDx = modulo === 0 ? 3 : modulo === 1 ? 2 : 1;
	  if (dir.y === 1) { 
		//guarda in basso - palpebre sopra
		ctx.arc(ex1, ey1 - spostamentoSx, eyeSize, Math.PI, 2 * Math.PI);
		ctx.arc(ex2, ey2 - spostamentoDx, eyeSize, Math.PI, 2 * Math.PI);
	  } else if (dir.y === -1) { 
		//guarda in alto - palpebre sotto
		ctx.arc(ex1, ey1 + spostamentoSx, eyeSize, 0, Math.PI);
		ctx.arc(ex2, ey2 + spostamentoDx, eyeSize, 0, Math.PI);
	  } else if (dir.x === 1) { 
		//guarda a destra - palpebre a sinistra
		ctx.arc(ex1 - spostamentoSx, ey1, eyeSize, Math.PI / 2, Math.PI * 3 / 2);
		ctx.arc(ex2 - spostamentoDx, ey2, eyeSize, Math.PI / 2, Math.PI * 3 / 2);
	  } else { 
		//guarda a sinistra - palpebre a destra
		ctx.arc(ex1 + spostamentoSx, ey1, eyeSize, -Math.PI / 2, Math.PI / 2);
		ctx.arc(ex2 + spostamentoDx, ey2, eyeSize, -Math.PI / 2, Math.PI / 2);
	  }
	  ctx.fill();
  }  
  
  //bocca o lingua in base alla distanza dalla mela piu vicina
  let distanceAppleSnake = 999;
  for(let i = 0; i < apples.length; i++) {
	let dist = Math.sqrt( (apples[i].x - curr.x)*(apples[i].x - curr.x) + (apples[i].y - curr.y)*(apples[i].y - curr.y) );
	if (dist < distanceAppleSnake) distanceAppleSnake = dist;
  }
  
  if(distanceAppleSnake <= 3) {
    //bocca rossa + grande se vicina alla mela
    const mounthSize = cell / ( Math.max(distanceAppleSnake, 3));
	const noseWidth = cell / 12;
    const noseHeight = cell / 12;
	
	if (dir.x === 1) {
	  ctx.beginPath();
	  ctx.fillStyle = COLORS.red;
      ctx.arc(cx + mounthSize, cy, mounthSize, Math.PI / 2, -Math.PI / 2, true);
	  ctx.fill();
	  ctx.beginPath();
	  ctx.fillStyle = COLORS.black;
	  ctx.fillRect(ex1 + eyeSize * 1.5, ey1 - noseHeight / 2, noseWidth, noseHeight);
      ctx.fillRect(ex2 + eyeSize * 1.5, ey2 - noseHeight / 2, noseWidth, noseHeight);
	  ctx.fill();
    } else if (dir.x === -1) {
	  ctx.beginPath();
	  ctx.fillStyle = COLORS.red;
      ctx.arc(cx - mounthSize, cy, mounthSize, -Math.PI / 2, Math.PI / 2, true);
	  ctx.fill();
	  ctx.beginPath();
	  ctx.fillStyle = COLORS.black;
	  ctx.fillRect(ex1 - eyeSize * 1.5 - noseWidth, ey1 - noseHeight / 2, noseWidth, noseHeight);
      ctx.fillRect(ex2 - eyeSize * 1.5 - noseWidth, ey2 - noseHeight / 2, noseWidth, noseHeight);
	  ctx.fill();
    } else if (dir.y === 1) {
	  ctx.beginPath();
      ctx.fillStyle = COLORS.red;
	  ctx.arc(cx, cy + mounthSize, mounthSize, 0, Math.PI, false);
	  ctx.fill();
	  ctx.beginPath();
	  ctx.fillStyle = COLORS.black;
	  ctx.fillRect(ex1 - noseWidth / 2, ey1 + eyeSize * 1.5, noseWidth, noseHeight);
      ctx.fillRect(ex2 - noseWidth / 2, ey2 + eyeSize * 1.5, noseWidth, noseHeight);
	  ctx.fill();
    } else {
	  ctx.beginPath();
      ctx.fillStyle = COLORS.red;
	  ctx.arc(cx, cy - mounthSize, mounthSize, Math.PI, 0, false);
	  ctx.fill();
	  ctx.beginPath();
	  ctx.fillStyle = COLORS.black;
	  ctx.fillRect(ex1 - noseWidth / 2, ey1 - eyeSize * 1.5 - noseHeight, noseWidth, noseHeight);
      ctx.fillRect(ex2 - noseWidth / 2, ey2 - eyeSize * 1.5 - noseHeight, noseWidth, noseHeight);
	  ctx.fill();
    }    
  } else {
    //linguetta biforcuta + narici
	let modulo = ((curr.x | 0) + (curr.y | 0)) % 3;
	let divisore = (modulo === 0 ? 4 : modulo === 1 ? 2 : 12)
    const tongueLength =  cell / divisore;//distanceAppleSnake;
	const noseWidth = cell / 12;
    const noseHeight = cell / 12;
	
	ctx.strokeStyle = COLORS.red;
    ctx.lineWidth = 2;
    ctx.beginPath();
    if (dir.x === 1) {
      ctx.moveTo(cx + cell / 2.2, cy);
      ctx.lineTo(cx + tongueLength + cell / 1.4, cy);
      ctx.lineTo(cx + tongueLength + cell / 1.3, cy - 3);
      ctx.moveTo(cx + tongueLength + cell / 1.4, cy);
      ctx.lineTo(cx + tongueLength + cell / 1.3, cy + 3);
	  
	  ctx.fillRect(ex1 + eyeSize * 2, ey1 - noseHeight / 2, noseWidth, noseHeight);
      ctx.fillRect(ex2 + eyeSize * 2, ey2 - noseHeight / 2, noseWidth, noseHeight);
    } else if (dir.x === -1) {
      ctx.moveTo(cx - cell / 2.2, cy);
      ctx.lineTo(cx - tongueLength - cell / 1.4, cy);
      ctx.lineTo(cx - tongueLength - cell / 1.3, cy - 3);
      ctx.moveTo(cx - tongueLength - cell / 1.4, cy);
      ctx.lineTo(cx - tongueLength - cell / 1.3, cy + 3);
	  
	  ctx.fillRect(ex1 - eyeSize * 2 - noseWidth, ey1 - noseHeight / 2, noseWidth, noseHeight);
      ctx.fillRect(ex2 - eyeSize * 2 - noseWidth, ey2 - noseHeight / 2, noseWidth, noseHeight);
    } else if (dir.y === 1) {
      ctx.moveTo(cx, cy + cell / 2.2);
      ctx.lineTo(cx, cy + tongueLength + cell / 1.4);
      ctx.lineTo(cx - 3, cy + tongueLength + cell / 1.3);
      ctx.moveTo(cx, cy + tongueLength + cell / 1.4);
      ctx.lineTo(cx + 3, cy + tongueLength + cell / 1.3);
	  
	  ctx.fillRect(ex1 - noseWidth / 2, ey1 + eyeSize * 2, noseWidth, noseHeight);
      ctx.fillRect(ex2 - noseWidth / 2, ey2 + eyeSize * 2, noseWidth, noseHeight);
    } else {
      ctx.moveTo(cx, cy - cell / 2.2);
      ctx.lineTo(cx, cy - tongueLength - cell / 1.4);
      ctx.lineTo(cx - 3, cy - tongueLength - cell / 1.3);
      ctx.moveTo(cx, cy - tongueLength - cell / 1.4);
      ctx.lineTo(cx + 3, cy - tongueLength - cell / 1.3);
	  
	  ctx.fillRect(ex1 - noseWidth / 2, ey1 - eyeSize * 2 - noseHeight, noseWidth, noseHeight);
      ctx.fillRect(ex2 - noseWidth / 2, ey2 - eyeSize * 2 - noseHeight, noseWidth, noseHeight);
    }
    ctx.stroke();
  }
  
  //corona
  if (hasCrown) {
    const crownWidth = cell * 1.2;
    const crownHeight = cell * 0.9;
    let crownX = cx;
	let crownY = cy;
  
    // Posiziona la corona sopra la testa, dietro la direzione
    if (dir.x === 1) crownX = cx - cell / 2.2 - crownHeight / 2; // guarda destra
    else if (dir.x === -1) crownX = cx + cell / 2.2 + crownHeight / 2; // guarda sinistra
    else if (dir.y === 1) crownY = cy - cell / 2.2 - crownHeight / 2; // guarda su
    else crownY = cy + cell / 2.2 + crownHeight / 2; // guarda gi√π
    
    ctx.save();
    ctx.translate(crownX, crownY);
	if (dir.x === 1) ctx.rotate(-Math.PI / 2);
    else if (dir.x === -1) ctx.rotate(Math.PI / 2);
    else if (dir.y === -1) ctx.rotate(Math.PI);
  
    // --- FASCIA: trapezio rovesciato ---
    const baseTop = crownWidth;
    const baseBottom = crownWidth * 0.6;
    const height = crownHeight * 0.5;
  
    ctx.fillStyle = "#fd0"; // oro
    ctx.strokeStyle = "#b80"; // oro scuro
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-baseBottom / 2, height / 2);
    ctx.lineTo(baseBottom / 2, height / 2);
    ctx.lineTo(baseTop / 2, -height / 2);
    ctx.lineTo(-baseTop / 2, -height / 2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  
    // --- PUNTE ---
    const tipHeight = crownHeight * 0.4;
    const tipPositions = [
      -baseTop / 3, // sinistra
      0,            // centro
      baseTop / 3   // destra
    ];
  
    ctx.beginPath();
    for (let i = 0; i < tipPositions.length; i++) {
      const x = tipPositions[i];
      const tipBaseY = -height / 2;
      ctx.moveTo(x - baseTop / 6, tipBaseY);
      ctx.lineTo(x, tipBaseY - tipHeight);
      ctx.lineTo(x + baseTop / 6, tipBaseY);
      ctx.closePath();
    }
    ctx.fill();
    ctx.stroke();
  
    // --- GEMME sulle punte ---
    const gemColors = ["#f00", "#0f0", "#00f"];
    const gemRadius = crownWidth * 0.1;
    for (let i = 0; i < tipPositions.length; i++) {
      const x = tipPositions[i];
      const y = -height / 2 - tipHeight;
      ctx.fillStyle = gemColors[i];
      ctx.beginPath();
      ctx.arc(x, y - gemRadius * 0.6, gemRadius, 0, Math.PI * 2);
      ctx.fill();
	  ctx.strokeStyle = COLORS.white;
	  ctx.arc(x, y - gemRadius * 0.6, gemRadius * 1.2, 0, Math.PI * 2);
	  ctx.stroke();
  
      // riflesso bianco
      ctx.fillStyle = "rgba(255,255,255,0.6)";
      ctx.beginPath();
      ctx.arc(x - gemRadius / 3, y - gemRadius, gemRadius / 3, 0, Math.PI * 2);
      ctx.fill();
    }
  
    ctx.restore();
  }
}

//mela
function drawApple(ctx, apple) {
  const cx = apple.x * cell + cell / 2;
  const cy = apple.y * cell + cell / 2;
  const r = 2 * cell / 3;

  //corpo gradiente radiale rosso luccicoso
  const grad = ctx.createRadialGradient(cx - r/3, cy - r/3, r/4, cx, cy, r);
  grad.addColorStop(0, COLORS.appleRedLight);
  grad.addColorStop(0.5, COLORS.appleRedMed);
  grad.addColorStop(1, COLORS.appleRedDark);
  ctx.fillStyle = grad;

  //melazza
  ctx.beginPath();
  ctx.ellipse(cx, cy, r, 3*r/5, 0, 0, Math.PI * 2);//schiacciata
  ctx.closePath();
  ctx.fill();

  //luce
  ctx.beginPath();
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.ellipse(cx - r/3, cy - r/3, r/3, r/5, 0, 0, Math.PI*2);
  ctx.fill();

  //picciolo
  ctx.strokeStyle = COLORS.brown;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(cx, cy - r);
  ctx.lineTo(cx, cy - r + 4);
  ctx.stroke();

  //foglietta
  ctx.fillStyle = COLORS.medGreen;
  ctx.beginPath();
  ctx.moveTo(cx, cy - r - 1);
  ctx.quadraticCurveTo(cx + 4, cy - r - 1, cx + 8, cy - r);
  ctx.quadraticCurveTo(cx + 4, cy - r + 4, cx, cy - r - 1);
  ctx.fill();
}

//w la zucca
function drawPumpkin(ctx, pumpkin) {
  const cx = pumpkin.x * cell + cell / 2;
  const cy = pumpkin.y * cell + cell / 2;
  const r = 2 * cell / 3;

  // corpo della zucca (arancione con ombreggiatura)
  const grad = ctx.createRadialGradient(cx - r/4, cy - r/4, r/8, cx, cy, r);
  grad.addColorStop(0, '#fb4');  // luce arancione chiara
  grad.addColorStop(0.5, '#f90');// arancione medio
  grad.addColorStop(1, '#a50');  // ombra marrone-arancio
  ctx.fillStyle = grad;

  ctx.beginPath();
  ctx.ellipse(cx, cy, r * 0.9, r * 0.85, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.closePath();

  // scanalature verticali (righe scure che danno effetto zucca)
  ctx.strokeStyle = 'rgba(80,40,0,0.15)';
  ctx.lineWidth = 1;
  for (let i = -2; i <= 2; i++) {
    ctx.beginPath();
    ctx.ellipse(cx + (i * r * 0.18), cy, r * 0.6, r * 0.85, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.closePath();
  }

  // gambo verde in alto
  const stemH = r * 0.35;
  const stemW = r * 0.25;
  ctx.beginPath();
  ctx.fillStyle = COLORS.green;
  ctx.moveTo(cx - stemW / 2, cy - r * 0.9);
  ctx.lineTo(cx + stemW / 2, cy - r * 0.9);
  ctx.lineTo(cx + stemW * 0.4, cy - r - stemH);
  ctx.lineTo(cx - stemW * 0.4, cy - r - stemH);
  ctx.closePath();
  ctx.fill();

  //jack-o-lantern :)
  ctx.fillStyle = COLORS.black;
  const eyeOffsetX = r * 0.3;
  const eyeOffsetY = r * 0.15;
  const eyeSize = r * 0.25;

  //occhi a triangolo
  ctx.beginPath();
  ctx.moveTo(cx + eyeOffsetX - eyeSize, cy - eyeOffsetY + eyeSize / 3);
  ctx.lineTo(cx + eyeOffsetX + eyeSize, cy - eyeOffsetY - eyeSize);
  ctx.lineTo(cx + eyeOffsetX + eyeSize, cy - eyeOffsetY + eyeSize / 2);
  ctx.closePath();
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(cx - eyeOffsetX + eyeSize, cy - eyeOffsetY + eyeSize / 3);
  ctx.lineTo(cx - eyeOffsetX - eyeSize, cy - eyeOffsetY - eyeSize);
  ctx.lineTo(cx - eyeOffsetX - eyeSize, cy - eyeOffsetY + eyeSize / 2);
  ctx.closePath();
  ctx.fill();

  //sorriso spaventevole
  ctx.beginPath();
  const mouthY = cy + r * 0.35;
  const mouthW = r * 0.9;
  const mouthH = r * 0.5;
  ctx.moveTo(cx - mouthW / 2, mouthY);
  ctx.quadraticCurveTo(cx, mouthY + mouthH * 0.3, cx + mouthW / 2, mouthY);
  ctx.quadraticCurveTo(cx, mouthY + mouthH, cx - mouthW / 2, mouthY);
  ctx.closePath();
  ctx.fill();
}



//bombetta
function drawBomb(ctx, bomb) {
  const cx = bomb.x * cell + cell / 2;
  const cy = bomb.y * cell + cell / 2;
  const r = 2 * cell / 3;

  // corpo scuro con gradiente metallico
  const grad = ctx.createRadialGradient(cx - r/4, cy - r/4, r/8, cx, cy, r);
  grad.addColorStop(0, COLORS.lightGray);//leggero highlight centrale
  grad.addColorStop(0.25, COLORS.medGray);
  grad.addColorStop(1, COLORS.black);//COLORS.darkGray);
  ctx.fillStyle = grad;

  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fill();
  ctx.closePath();

  // riflesso piccolo brillante
  ctx.beginPath();
  ctx.fillStyle = 'rgba(255,255,255,0.18)';
  ctx.ellipse(cx - r/3, cy - r/3, r/3.5, r/6, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.closePath();

  // cucitura / linea circolare leggermente pi√π scura (come giunzione della sfera)
  ctx.beginPath();
  ctx.strokeStyle = 'rgba(0,0,0,0.25)';
  ctx.lineWidth = Math.max(1, cell * 0.06);
  ctx.arc(cx, cy, r * 0.85, 0, Math.PI * 2);
  ctx.stroke();
  ctx.closePath();

  // stoppino: linea spessa e curvata verso l'alto
  const fuseLen = r * 0.5;
  const fx = cx;
  const fy = cy - r - 2;
  ctx.beginPath();
  ctx.strokeStyle = COLORS.lightGray;
  ctx.lineWidth = Math.max(2, cell * 0.06);
  ctx.lineCap = 'round';
  ctx.moveTo(fx, fy);
  // un piccolo zig-zag per renderlo pi√π naturale
  ctx.lineTo(fx - fuseLen * 0.25, fy - fuseLen * 0.25);
  ctx.lineTo(fx + fuseLen * 0.15, fy - fuseLen * 0.5);
  ctx.lineTo(fx - fuseLen * 0.05, fy - fuseLen * 0.7);
  ctx.stroke();
  ctx.closePath();

  // miccia finale (parte accesa) -> piccolo bagliore/fiammella
  const flameX = fx - fuseLen * 0.05;
  const flameY = fy - fuseLen * 0.75;
  // alone luminoso
  ctx.beginPath();
  ctx.fillStyle = 'rgba(255,160,50,0.35)';
  ctx.ellipse(flameX, flameY, cell * 0.35, cell * 0.18, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.closePath();

  // fiamma interna
  ctx.beginPath();
  const flameGrad = ctx.createRadialGradient(flameX, flameY, 1, flameX, flameY, cell * 0.35);
  flameGrad.addColorStop(0, 'rgba(255,255,160,1)');
  flameGrad.addColorStop(0.5, 'rgba(255,140,40,0.9)');
  flameGrad.addColorStop(1, 'rgba(220,60,10,0.8)');
  ctx.fillStyle = flameGrad;
  ctx.ellipse(flameX, flameY, cell * 0.22, cell * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.closePath();

  // opzionale: piccolo simbolo (skull) ‚Äî semplice croce per dare "pericolo"
  ctx.beginPath();
  ctx.fillStyle = COLORS.white;
  ctx.font = `${Math.max(8, cell * 0.5)}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('üíÄ', cx, cy + r * 0.05);
  ctx.closePath();
}

//granata
function drawGrenade(ctx, grenade) {
  const cx = grenade.x * cell + cell / 2;
  const cy = grenade.y * cell + cell / 2;
  const r = cell / 2;

  // Corpo ovale con gradiente metallico/verde oliva
  const grad = ctx.createLinearGradient(cx, cy - r, cx, cy + r);
  grad.addColorStop(0, '#6a7555');
  grad.addColorStop(0.5, '#4c533b');
  grad.addColorStop(1, '#3a3f2d');
  ctx.fillStyle = grad;

  // Corpo principale
  ctx.beginPath();
  ctx.ellipse(cx, cy, r * 0.85, r, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.closePath();

  // Linee di segmentazione (a rombi tipiche delle granate "pineapple")
  ctx.strokeStyle = 'rgba(0,0,0,0.35)';
  ctx.lineWidth = Math.max(1, cell * 0.05);
  for (let i = -2; i <= 2; i++) {
    const offset = (i * r * 0.3);
    ctx.beginPath();
    ctx.moveTo(cx - r * 0.4, cy + offset);
    ctx.lineTo(cx + r * 0.4, cy + offset);
    ctx.stroke();
    ctx.closePath();
  }

  for (let j = -1; j <= 1; j++) {
    const offset = (j * r * 0.3);
    ctx.beginPath();
    ctx.moveTo(cx + offset, cy - r * 1.0);
    ctx.lineTo(cx + offset, cy + r * 1.0);
    ctx.stroke();
    ctx.closePath();
  }

  // Testa metallica (spoletta)
  const topH = r * 0.35;
  ctx.beginPath();
  const topGrad = ctx.createLinearGradient(cx, cy - r - topH, cx, cy - r);
  topGrad.addColorStop(0, '#aaa');
  topGrad.addColorStop(1, '#666');
  ctx.fillStyle = topGrad;
  ctx.fillRect(cx - r * 0.55, cy - r - topH, r * 1.1, topH);
  ctx.closePath();

  // Leva (spoon)
  ctx.beginPath();
  ctx.strokeStyle = '#555';
  ctx.lineWidth = Math.max(2, cell * 0.07);
  ctx.lineCap = 'round';
  ctx.moveTo(cx + r * 0.5, cy - r - topH * 0.5);
  ctx.quadraticCurveTo(cx + r * 0.9, cy - r * 0.4, cx + r * 0.3, cy - r * 0.1);
  ctx.stroke();
  ctx.closePath();

  // Anello di sicurezza
  ctx.beginPath();
  ctx.strokeStyle = '#ccc';
  ctx.lineWidth = Math.max(1.5, cell * 0.05);
  ctx.arc(cx + r * 0.55, cy - r - topH * 0.2, cell * 0.3, 0, Math.PI * 2);
  ctx.stroke();
  ctx.closePath();

  // Leggero highlight centrale
  ctx.beginPath();
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.ellipse(cx - r * 0.4, cy - r * 0.2, r * 0.4, r * 0.9, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.closePath();
}


//burger king
function drawBurger(ctx, burger) {
  const cx = burger.x * cell + cell / 2;
  const cy = burger.y * cell + cell / 2;
  const r = cell * 0.60;
  const tilt = -Math.PI / 15;//inclinazione

  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(tilt);

  //panino superiore
  ctx.beginPath();
  const topGrad = ctx.createLinearGradient(0, -r, 0, 0);
  topGrad.addColorStop(0, '#fd8');
  topGrad.addColorStop(1, '#d82');
  ctx.fillStyle = topGrad;
  ctx.ellipse(0, -r * 0.3, r * 1.1, r * 0.5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.closePath();

  //insalatina
  ctx.beginPath();
  ctx.fillStyle = '#6b5';
  ctx.ellipse(0, -r * 0.05, r * 1.05, r * 0.25, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.closePath();

  //pomodoro
  ctx.beginPath();
  const tomatoGrad = ctx.createLinearGradient(0, -r * 0.1, 0, r * 0.1);
  tomatoGrad.addColorStop(0, '#f77');
  tomatoGrad.addColorStop(1, '#b22');
  ctx.fillStyle = tomatoGrad;
  ctx.ellipse(0, r * 0.05, r * 1.0, r * 0.22, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.closePath();

  //formaggio
  ctx.beginPath();
  ctx.fillStyle = '#fd5';
  ctx.moveTo(-r, r * 0.15);
  ctx.lineTo(r, r * 0.15);
  ctx.lineTo(r, r * 0.35);
  ctx.lineTo(-r, r * 0.35);
  ctx.closePath();
  ctx.fill();

  //carne
  ctx.beginPath();
  const meatGrad = ctx.createLinearGradient(0, r * 0.2, 0, r * 0.5);
  meatGrad.addColorStop(0, '#531');
  meatGrad.addColorStop(1, '#310');
  ctx.fillStyle = meatGrad;
  ctx.ellipse(0, r * 0.35, r * 1.05, r * 0.22, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.closePath();

  //panino inferiore
  ctx.beginPath();
  const bottomGrad = ctx.createLinearGradient(0, r * 0.35, 0, r * 0.85);
  bottomGrad.addColorStop(0, '#ea5');
  bottomGrad.addColorStop(1, '#c63');
  ctx.fillStyle = bottomGrad;
  ctx.ellipse(0, r * 0.6, r * 1.05, r * 0.25, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.closePath();

  ctx.restore();
}

//cocomero
function drawWatermelon(ctx, slice) {
  const cx = slice.x * cell + cell / 2;
  const cy = slice.y * cell + cell / 2;
  const r = cell * 0.6;          //raggio fetta
  const tilt = 6 * Math.PI / 5;  //inclinazione (negativo = verso sinistra)

  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(tilt);

  //buccia verde
  ctx.beginPath();
  ctx.moveTo(-r, 0);
  ctx.arc(0, 0, r * 1.1, Math.PI, 0, false);
  ctx.arc(0, 0, r * 1.02, 0, Math.PI, true);
  ctx.closePath();
  ctx.fillStyle = COLORS.medGreen;
  ctx.fill();

  //bianco
  ctx.beginPath();
  ctx.moveTo(-r, 0);
  ctx.arc(0, 0, r * 1.02, Math.PI, 0, false);
  ctx.arc(0, 0, r * 0.9, 0, Math.PI, true);
  ctx.closePath();
  ctx.fillStyle = COLORS.white;
  ctx.fill();

  //polpa rossa
  ctx.beginPath();
  ctx.moveTo(-r, 0);
  ctx.arc(0, 0, r * 0.9, Math.PI, 0, false);
  ctx.closePath();
  const redGrad = ctx.createLinearGradient(0, -r, 0, r);
  redGrad.addColorStop(0, '#ff4b4b');
  redGrad.addColorStop(1, '#c01818');
  ctx.fillStyle = redGrad;
  ctx.fill();

  //semini
  const angleStep = 45 * Math.PI / 180; // 20 gradi in radianti
  const startAngle = Math.PI + angleStep / 2;           // 180¬∞ (lato sinistro)
  const endAngle = 2 * Math.PI - angleStep / 2;         // 360¬∞ (lato destro)
  
  for (let angle = startAngle; angle <= endAngle; angle += angleStep) {
    const dist = r * 0.55;
    const sx = Math.cos(angle) * dist;
    const sy = Math.sin(angle) * dist * 0.75;
    const rot = angle - Math.PI / 2;

    ctx.save();
    ctx.translate(sx, sy); //niente pi√π cx, cy
    ctx.rotate(rot);
    ctx.beginPath();
    ctx.ellipse(0, 0, cell * 0.08, cell * 0.12, 0, 0, Math.PI * 2);
    ctx.fillStyle = COLORS.darkGray;
    ctx.fill();
    ctx.closePath();
    ctx.restore();
  }

  //riflesso
  ctx.beginPath();
  ctx.fillStyle = 'rgba(255,255,255,0.18)';
  ctx.ellipse(-r * 0.25, -r * 0.3, r * 0.25, r * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.closePath();

  ctx.restore();
}




//weeee funghetto!!!
function drawMushroom(ctx, poison) {
  const cx = poison.x * cell + cell / 2;
  const cy = poison.y * cell + cell / 2;
  const stemH = cell * 0.6;       //altezza gambo
  const stemW = cell * 0.4;       //larghezza gambo
  const capR = cell * 0.65;       //raggio cappello

  //gambo
  ctx.beginPath();
  ctx.roundRect(cx - stemW / 2, cy, stemW, stemH, stemW / 3);
  const stemGrad = ctx.createLinearGradient(cx, cy, cx, cy + stemH);
  stemGrad.addColorStop(0, '#f5e7c6');
  stemGrad.addColorStop(1, '#e2cfa0');
  ctx.fillStyle = stemGrad;
  ctx.fill();
  ctx.lineWidth = Math.max(1, cell * 0.06);
  ctx.strokeStyle = '#bda981';
  ctx.stroke();

  //cappella rossa sfumata (sto zozzo)
  const grad = ctx.createLinearGradient(cx - capR, cy - capR, cx + capR, cy);
  grad.addColorStop(0, '#b80000');
  grad.addColorStop(0.5, '#ff1a1a');
  grad.addColorStop(1, '#b80000');

  ctx.beginPath();
  ctx.ellipse(cx, cy, capR, capR * 0.8, 0, Math.PI, 0);
  ctx.closePath();
  ctx.fillStyle = grad;
  ctx.fill();
  ctx.strokeStyle = '#7a0000';
  ctx.lineWidth = Math.max(1, cell * 0.07);
  ctx.stroke();

  //puntini bianchi
  const spots = [
    { dx: -capR * 0.65, dy: -capR * 0.50, r: capR * 0.13 },
    { dx: -capR * 0.35, dy: -capR * 0.65, r: capR * 0.12 },
    { dx:  0,           dy: -capR * 0.7,  r: capR * 0.11 },
    { dx:  capR * 0.35, dy: -capR * 0.60, r: capR * 0.12 },
    { dx:  capR * 0.65, dy: -capR * 0.45, r: capR * 0.13 },
	{ dx: -capR * 0.2,  dy: -capR * 0.45, r: capR * 0.09 },
    { dx:  capR * 0.2,  dy: -capR * 0.40, r: capR * 0.09 },
  ];

  ctx.fillStyle = COLORS.white;
  spots.forEach(s => {
    ctx.beginPath();
    ctx.arc(cx + s.dx, cy + s.dy, s.r, 0, Math.PI * 2);
    ctx.fill();
  });

  //ombra sotto il cappello
  ctx.beginPath();
  ctx.ellipse(cx, cy + cell * 0.05, capR * 0.9, capR * 0.3, 0, 0, Math.PI);
  const shadowGrad = ctx.createLinearGradient(cx, cy, cx, cy + cell * 0.3);
  shadowGrad.addColorStop(0, 'rgba(0,0,0,0.5)');
  shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = shadowGrad;
  ctx.fill();
}


//veleno!!!
function drawPoison(ctx, poison) {
  const cx = poison.x * cell + cell / 2;
  const cy = poison.y * cell + cell / 2;
  const w = cell * 0.8;      // larghezza barile
  const h = cell * 1.4;      // altezza barile
  const r = 4;               // angolo arrotondato

  //corpo del barile giallo
  const yellowGrad = ctx.createLinearGradient(cx - w / 2, cy, cx + w / 2, cy);
  yellowGrad.addColorStop(0, '#c90');
  yellowGrad.addColorStop(0.5, '#fc0');
  yellowGrad.addColorStop(1, '#c90');

  ctx.beginPath();
  ctx.roundRect(cx - w / 2, cy - h / 2, w, h, r);
  ctx.fillStyle = yellowGrad;
  ctx.fill();
  ctx.lineWidth = Math.max(1, cell * 0.06);
  ctx.strokeStyle = COLORS.darkGray;
  ctx.stroke();

  //bande nere sopra+sotto
  const bandH = 2;
  ctx.fillStyle = COLORS.black;
  ctx.fillRect(cx - w / 2, cy - h / 2, w, bandH);
  ctx.fillRect(cx - w / 2, cy + h / 2 - bandH, w, bandH);

  //cerchio centrale
  ctx.beginPath();
  ctx.arc(cx, cy + cell * 0.1, cell / 2.5, 0, Math.PI * 2);
  ctx.fillStyle = COLORS.black;
  ctx.fill();
  
  //skull
  ctx.beginPath();
  ctx.fillStyle = COLORS.white;
  ctx.font = `${Math.max(8, cell * 0.5)}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('‚ò¢Ô∏è', cx, cy + r / 2);
  ctx.closePath();
}



//ciliegie
function drawCherries(ctx, fruit) {
  const cx = fruit.x * cell + cell / 2;
  const cy = fruit.y * cell + cell / 2;

  ctx.save();
  ctx.translate(cx, cy);
  ctx.scale(cell / 20, cell / 20); // scala proporzionale per qualsiasi cella

  //ciliegie
  ctx.fillStyle = COLORS.red;
  ctx.beginPath();
  ctx.arc(-4, 3, 4, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(4, 5, 4, 0, Math.PI * 2);
  ctx.fill();

  //gambi
  ctx.strokeStyle = COLORS.green;
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-4, -1);
  ctx.lineTo(0, -8);
  ctx.lineTo(4, 1);
  ctx.stroke();

  //riflessi bianchi
  ctx.fillStyle = COLORS.white;
  ctx.beginPath();
  ctx.arc(-5.2, 2, 1.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(2.8, 4, 1.2, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}



//banana!!!
function drawBanana(ctx, banana) {
  const cx = banana.x * cell + cell / 2;
  const cy = banana.y * cell + cell / 2;
  const r = 3 * cell / 5;

  //gradiente giallo caldo
  const grad = ctx.createLinearGradient(cx, cy - r, cx, cy + r * 1.5);
  grad.addColorStop(0, '#ff9');
  grad.addColorStop(0.5, '#fd3');
  grad.addColorStop(1, '#a70');
  ctx.fillStyle = grad;
  ctx.strokeStyle = '#b90';
  ctx.lineWidth = 2;

  ctx.beginPath();
  
  //curva superiore
  ctx.moveTo(cx - r, cy - r / 3);
  ctx.quadraticCurveTo(cx, cy + r * 0.5, cx + r, cy);
  ctx.quadraticCurveTo(cx, cy + r * 1.6, cx - r, cy - r / 10);
  
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
}





//scacchiera background
function drawBackground(ctx, rows, cols) { 
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      if (x < padding || y < padding || x >= (cols - padding) || y >= (rows - padding)) {
		ctx.fillStyle = COLORS['backgroundBorder'+currentSnakePattern];
	  }
	  else { 
		ctx.fillStyle = (x + y) % 2 === 0 ? COLORS['backgroundLight'+currentSnakePattern] : COLORS['backgroundDark'+currentSnakePattern];
	  }
      ctx.fillRect(x * cell, y * cell, cell, cell);
    }
  }
}

//collisioni
function checkWallCollision(head) {
  if (head.x < padding || head.x >= (cols - padding))
    return true;
  if (head.y < padding || head.y >= (rows - padding))
    return true;
  	
  return checkSameCell(head, snake, 0);
}


//controlla l'array cella (x,y) vuota e distante da altre celle
function checkSameCell(obj, arr, distance) {
  for (let i = 0; i < arr.length; i++) {
      if (Math.abs(obj.x - arr[i].x) <= distance && Math.abs(obj.y - arr[i].y) <= distance) return true;
  }
  return false;
}

//mangiata la mela/bomba/banana -> respawn
function spawnObject(myArray, myType) {
  let valid = false;
  let attempts = 0;
  
  while (!valid) {
    valid = true;
	attempts++;
    
	let obj = {
      x: Math.floor(Math.random() * (cols - padding * 2)) + padding,
      y: Math.floor(Math.random() * (rows - padding * 2)) + padding,
	  type: myType
    };
	
	//distante da testa di serpente almeno 4 celle
    if (Math.abs(snake[0].x - obj.x) < 4 && Math.abs(snake[0].y - obj.y) < 4) valid = false;//troppo vicina    

    //controlla mela sopra serpente, altre mele, bombette e veleno
	valid = valid && !checkSameCell(obj, snake, 2) && !checkSameCell(obj, apples, 2);
    
	//se arrivo qui e' ok
	if (valid) { 
		myArray.push(obj); 
		return true; 
	}
	
	if (attempts == 20) {
	    //se arrivo qui dentro -> il serpente ha vinto!
		return false;
	}
  }
}

//controlli da tastiera (cambio solo al tick, non immediatamente!)
/*
document.addEventListener('keydown', e => {
  if (e.key === 'ArrowUp'    && dir.y !== 1  && nextDir.y !== 1)  nextDir = {x:0, y:-1};
  if (e.key === 'ArrowDown'  && dir.y !== -1 && nextDir.y !== -1) nextDir = {x:0, y:1};
  if (e.key === 'ArrowLeft'  && dir.x !== 1  && nextDir.x !== 1)  nextDir = {x:-1, y:0};
  if (e.key === 'ArrowRight' && dir.x !== -1 && nextDir.x !== -1) nextDir = {x:1, y:0};
  if (e.key === 'R' || e.key === 'r') reset();
});*/
//aggiunta gestione coda di input
document.addEventListener('keydown', e => {
  let newDir = null;
  if (e.key === 'ArrowUp')    newDir = {x: 0, y: -1};
  if (e.key === 'ArrowDown')  newDir = {x: 0, y: 1};
  if (e.key === 'ArrowLeft')  newDir = {x: -1, y: 0};
  if (e.key === 'ArrowRight') newDir = {x: 1, y: 0};

  if (e.key === 'R' || e.key === 'r') {
    reset();
    return;
  }
  
  if (e.key === 'F' || e.key === 'f') {
    isFps = !isFps;
	return;
  }
  
  if (e.key === 'M' || e.key === 'm') {
    isMute = !isMute;
	return;
  }
  
  if (e.key >= '0' && e.key <= '9') {
    spawnObject(apples, Number(e.key)); 
	return; 
  }
  
  if (e.key === 'G' || e.key === 'g') {
    currentSnakePattern = 7;
	return;
  }
  
  if (e.key === 'X' || e.key === 'x') {
    if(apples.length < 10) for (let i = 0; i < 11; i++) spawnObject(apples, i%11);
  }

  if (newDir) {
    const lastDir = inputQueue.length > 0 ? inputQueue[inputQueue.length - 1] : dir;
    //evita direzioni opposte o uguali
	let isOpposite = newDir.x === -lastDir.x && newDir.y === -lastDir.y;
	let isSame = newDir.x === lastDir.x && newDir.y === lastDir.y;
    if (!isOpposite && !isSame) {
      inputQueue.push(newDir);
      if (inputQueue.length > 30) inputQueue.shift();
    }
  }
});





let eyelidEnabled = 0;
let snakeEyesEnabled = 0;

//GIOCO
function tick() {
  if (!alive) return;
  
  //dir = nextDir;//aggiorna direzione solo al tick!
  // Applica la prossima direzione dalla coda, se esiste
  if (inputQueue.length > 0) {
    const next = inputQueue.shift();
    if (!(next.x === -dir.x && next.y === -dir.y)) {
      dir = next;
	  playSound(dir.y < 0 ? 'turn1Sound' : 
				dir.x > 0 ? 'turn2Sound' : 
				dir.y > 0 ? 'turn4Sound' :
				dir.x < 0 ? 'turn3Sound' :
				'turnSound');
    }
  }
  
  
  //crea nuova testa
  let newHead = { 
	x: snake[0].x + dir.x, 
	y: snake[0].y + dir.y,
	oldX: snake[0].x,
	oldY: snake[0].y
  }; 
  
  //palpebre
  if (eyelidEnabled > 0) eyelidEnabled = eyelidEnabled - 0.2;
  else eyelidEnabled = Math.random() < (godmodeEffect ? 0.08 : 0.02) ? 2 : 0;
  
  //occhio da serpente
  if (snakeEyesEnabled > 0) snakeEyesEnabled = snakeEyesEnabled - 0.2;
  else snakeEyesEnabled = Math.random() < (godmodeEffect ? 0.1 : 0.01) ? 2 : 0;
  
  //controlla collisioni
  let isWallCollision = checkWallCollision(newHead);
  if (isWallCollision && godmodeEffect === 0) {
    playSound('dieSound');
    alive = false;
	message.push({msg:'GAME OVER, PRESS (R) TO RESET!',dat:Date.now()});
	return;
  } else {
    if(newHead.x === 0) newHead.x = cols - (padding * 2);
	if(newHead.y === 0) newHead.y = rows - (padding * 2);
	if(newHead.x === (cols - padding)) newHead.x = padding;
	if(newHead.y === (rows - padding)) newHead.y = padding;
  }
  
  //aggiunge la testa in testa :-)
  snake.unshift(newHead);
  
  
  //check mela (respawn o taglia coda)
  let eatApple = false;
  let canSpawn = true;
  
  for (let i = 0; i < apples.length; i++) {
    if (newHead.x === apples[i].x && newHead.y === apples[i].y) {
	  eatApple = true;
	  drawStats = true;
	  applesEaten.push({x:apples[i].x, y:apples[i].y, when:Date.now()});
	  if(apples[i].type === 0) {
	    //meluzza!!!
	    apples.splice(i, 1);//rimuove l'elemento i dall'array
        
        canSpawn = spawnObject(apples, 0);//respawn
	    statsArray[0]++;
		
		//aggiungi oggetti random: bombette a volonta' + un po' di mele multiple + banane rare
	    let objectType = (Math.random() * 100) | 0;
		let type = -1;
	         if (objectType >= 0 && objectType < 5) type = 0; // altra mela
		else if (objectType > 10 && objectType < 15) type = 1; // banana
		else if (objectType > 20 && objectType < 25) type = 2; // fungo
		else if (objectType > 30 && objectType < 35) type = 3; // veleno
		else if (objectType > 40 && objectType < 45) type = 4; // granata
		else if (objectType > 50 && objectType < 55) type = 5; // bomba
		else if (objectType > 60 && objectType < 65) type = 6; // zucca
		else if (objectType > 70 && objectType < 75) type = 7; // cocomero
		else if (objectType > 80 && objectType < 85) type = 8; // paninazzo
		else if (objectType > 90 && objectType < 95) type = 9; // ciliegie
		else if (objectType > 95) type = 10;//rocky graffietto
		if (type !== -1) spawnObject(apples, type);
		playSound('eatSound');
	  } else if (apples[i].type === 1) { 
	    //banana!!!
		apples.splice(i, 1);//rimuove l'elemento i dall'array
		
		//effetti collaterali...
	  	bananaGrow = 8;
		statsArray[1]++;
		message.push({msg:'BANANA GROW!',dat:Date.now()});
		playSound('eatSound');
	  } else if (apples[i].type === 2) {
	    //fungo
		apples.splice(i, 1);//rimuove l'elemento i dall'array
		
		//effetti collaterali...
		poisonEffect = 30;
		statsArray[2]++;
		message.push({msg:'POISONED!',dat:Date.now()});
		playSound('eatSound');
	  } else if (apples[i].type === 3) {
	    //poison
		apples.splice(i, 1);//rimuove l'elemento i dall'array
		
		//effetti collaterali...
		poisonEffect = 60;
		statsArray[3]++;
		message.push({msg:'SUPER-POISONED!',dat:Date.now()});
		playSound('eatSound');
	  } else if (apples[i].type === 4) {
	    //bombetta/granata
		apples.splice(i, 1);//rimuove l'elemento i dall'array
		
		//effetti collaterali...
		statsArray[4]++;
		if (godmodeEffect === 0) { 
		  playSound('dieSound');
          alive = false;		
		  message.push({msg:'GAME OVER, PRESS (R) TO RESET!',dat:Date.now()});
		  return; 
		} else {
		  eatApple = true;
		  playSound('eatSound');
		  message.push({msg:'KA-BOOM!',dat:Date.now()});
		}
	  } else if (apples[i].type === 5) {
	    //bombetta/granata
		apples.splice(i, 1);//rimuove l'elemento i dall'array
		
		//effetti collaterali...
		statsArray[5]++;
		if (godmodeEffect === 0) {
		  playSound('dieSound');
		  alive = false;
		  message.push({msg:'GAME OVER, PRESS (R) TO RESET!',dat:Date.now()});
		  return;
		} else {
		  eatApple = true;
		  playSound('eatSound');
		  message.push({msg:'OUCH!',dat:Date.now()});
		}
	  } else if (apples[i].type === 6) {
	    //skeletor
		apples.splice(i, 1);//rimuove l'elemento i dall'array
		
		//effetti collaterali...
		skeletorFactor = 0.1;
		burgerFactor = 1;
		statsArray[6]++;
		message.push({msg:'HALLOWEEN MODE!',dat:Date.now()});
		playSound('eatSound');
	  } else if (apples[i].type === 7) {
	    //cocomero
		apples.splice(i, 1);//rimuove l'elemento i dall'array
		
		//effetti collaterali...
	  	bananaGrow = 16;
		statsArray[7]++;
		message.push({msg:'WATERMELON GROW!',dat:Date.now()});
		playSound('eatSound');
	  }	else if (apples[i].type === 8) {
	    //burger king
		apples.splice(i, 1);//rimuove l'elemento i dall'array
		
		//effetti collaterali...
		skeletorFactor = 1;
		burgerFactor = 2;
		statsArray[8]++;
		message.push({msg:'BURGER KING MODE!',dat:Date.now()});
		playSound('eatSound');
	  }	else if (apples[i].type === 9) {
	    //ciliegie
		apples.splice(i, 1);//rimuove l'elemento i dall'array
		
		//effetti collaterali...
		statsArray[9]++;
		godmodeEffect = 60;
		message.push({msg:'GOD MODE!',dat:Date.now()});
		playSound('eatSound');
	  }	else if (apples[i].type === 10) {
	    //rocky graffietto
		apples.splice(i, 1);//rimuove l'elemento i dall'array
		
		//effetti collaterali...
		statsArray[10]++;
		message.push({msg:'OH NO... ROCKY GRAFFIETTO MODE!',dat:Date.now()});
		playSound('catSound');
		for(let i = 0; i < apples.length; i++) {
		  if (apples[i].type !== 0) apples[i].type = 10;
		}
		currentSnakePattern = 8;
	  }	
    }
  }
  
  //gestisce skeletrazzi
  if (skeletorFactor < 1) {
    skeletorFactor += 0.025;
	currentSnakePattern = 4;
	if (skeletorFactor > 1) {
	  skeletorFactor = 1;
	  currentSnakePattern = 0;
	}
  }
  
  //gestisce cicciazza
  if (burgerFactor > 1) {
    burgerFactor -= 0.025;
	currentSnakePattern = 5;
	if (burgerFactor < 1) {
	  burgerFactor = 1;
	  currentSnakePattern = 0;
	}
  }
  
  //gestisce crescita da banana
  if (bananaGrow > 0) {
    bananaGrow--;
	if (bananaGrow === 0) {
	  currentSnakePattern = 0;
	}
  }
  
  //gestisce serpentone drogato
  if (poisonEffect > 0) {
    sgamolla();//smonta serpentone
	currentSnakePattern = (currentSnakePattern+1) % 4;
	poisonEffect--;
	if (poisonEffect === 0) {
	  currentSnakePattern = 0;
	}
  }
  
  //gestisce godmodeEffect
  if (godmodeEffect > 0) {
    godmodeEffect--;
	currentSnakePattern = 6;
	if (godmodeEffect === 0) {
	  currentSnakePattern = 0;
	}
  }
  
  if (!(eatApple || bananaGrow)) {
    //toglie la coda
    if(snake.length > snakeMinLength) {
	  snake.pop();
	  snakeMinLength = 1;
	}
  }
  
  if (!canSpawn) {
    //svuota la griglia
	apples = [ { x: 5, y: 5, type: 0 } ];
  }
  
  //DISEGNA!!!
  //drawAll()
}

//difficile tradurre in italiano, figuriamoci in inglese...
function sgamolla() {
  for (let i = 1; i < snake.length; i++) {
    snake[i].x += (Math.random() - 0.5) * 0.25; // ¬±0.25 celle
    snake[i].y += (Math.random() - 0.5) * 0.25;
  }
}

function drawAll() {
  //clear
  gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

  //scacchiera
  drawBackground(gameCtx, rows, cols);
  
  //mela/banana/funghi/bombette
  for (let i = 0; i < apples.length; i++) {
    switch(apples[i].type) {
	  case 0: drawApple(gameCtx, apples[i]); break;
	  case 1: drawBanana(gameCtx, apples[i]); break;
	  case 2: drawMushroom(gameCtx, apples[i]); break;
	  case 3: drawPoison(gameCtx, apples[i]); break;
	  case 4: drawGrenade(gameCtx, apples[i]); break;
	  case 5: drawBomb(gameCtx, apples[i]); break;
	  case 6: drawPumpkin(gameCtx, apples[i]); break;
	  case 7: drawWatermelon(gameCtx, apples[i]); break;
	  case 8: drawBurger(gameCtx, apples[i]); break;
	  case 9: drawCherries(gameCtx, apples[i]); break;
	  case 10: drawRockyGraffietto(gameCtx, apples[i]); break;
	}
  }
  
    
  //corpo
  for (let i = 1; i < snake.length; i++) {
    //console.log('B '+i+' >> '+snake[i].x+' '+snake[i].y);
    drawSegment(gameCtx, snake[i], snake[i - 1], i == snake.length - 1);
  }
  
  //testa
  //console.log('H '+0+' >> '+snake[0].x+' '+snake[0].y);
  drawHead(gameCtx, snake[0], dir);
}

//let inter = setInterval(tick, 200);


function drawStatsArray(ctx, canvas) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  drawBackground(ctx, statsRows, statsCols);
  
  ctx.font = `${Math.max(8, cell * 0.5)}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  let fakeObj = {x:0, y:1};
  ctx.fillStyle = COLORS.white;
  ctx.fillText('STATS:', fakeObj.x * cell + 2.5 * cell, fakeObj.y * cell + cell / 2);
  
  let total = 0;
  for (let type = 0; type < 11; type++) {
    fakeObj = {x:2, y:(type*2)+2};
    switch(type) {
	  case 0: drawApple(ctx, fakeObj); break;
	  case 1: drawBanana(ctx, fakeObj); break;
	  case 2: drawMushroom(ctx, fakeObj); break;
	  case 3: drawPoison(ctx, fakeObj); break;
	  case 4: drawGrenade(ctx, fakeObj); break;
	  case 5: drawBomb(ctx, fakeObj); break;
	  case 6: drawPumpkin(ctx, fakeObj); break;
	  case 7: drawWatermelon(ctx, fakeObj); break;
	  case 8: drawBurger(ctx, fakeObj); break;
	  case 9: drawCherries(ctx, fakeObj); break;
	  case 10: drawRockyGraffietto(ctx, fakeObj); break;//HIDDEN!!!
	}
	ctx.fillStyle = COLORS.white;
    ctx.fillText(statsArray[type], fakeObj.x * cell + 2.5 * cell, fakeObj.y * cell + cell / 2);
	total+=statsArray[type];
	if (total > 50) hasCrown = true; 
	else hasCrown = false;
  }
  ctx.fillStyle = COLORS.white;
  fakeObj = {x:0, y:20+3};
  ctx.fillText('TOTAL: ', fakeObj.x * cell + 2.5 * cell, fakeObj.y * cell + cell / 2);
  fakeObj = {x:2, y:20+3};
  ctx.fillText(total, fakeObj.x * cell + 2.5 * cell, fakeObj.y * cell + cell / 2);
  drawStats = false;
}


// loop fluido con interpolazione testa
let lastTime = 0;
const moveDelay = 200;
let moveTimer = 0;

function gameLoop(timestamp) {
  if (!alive) return;
  const delta = timestamp - lastTime;
  lastTime = timestamp;
  moveTimer += delta;

  // passo logico
  if (moveTimer >= moveDelay) {
    moveTimer -= moveDelay;
    tick();
  }

  const t = moveTimer / moveDelay;

  //clear
  gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

  //scacchiera
  drawBackground(gameCtx, rows, cols);
  
  //mela/banana/funghi/bombette
  for (let i = 0; i < apples.length; i++) {
    switch(apples[i].type) {
	  case 0: drawApple(gameCtx, apples[i]); break;
	  case 1: drawBanana(gameCtx, apples[i]); break;
	  case 2: drawMushroom(gameCtx, apples[i]); break;
	  case 3: drawPoison(gameCtx, apples[i]); break;
	  case 4: drawGrenade(gameCtx, apples[i]); break;
	  case 5: drawBomb(gameCtx, apples[i]); break;
	  case 6: drawPumpkin(gameCtx, apples[i]); break;
	  case 7: drawWatermelon(gameCtx, apples[i]); break;
	  case 8: drawBurger(gameCtx, apples[i]); break;
	  case 9: drawCherries(gameCtx, apples[i]); break;
	  case 10: drawRockyGraffietto(gameCtx, apples[i]); break;
	}
  }
  
  
  //console.log('t='+t+' snake=',snake);
    
  //corpo
  for (let i = 1; i < snake.length; i++) {
    drawSegment(gameCtx, snake[i], snake[i-1], i === snake.length - 1);
  }

  // testa
  const headDeltaX = snake[0].x - snake[0].oldX;
  const headDeltaY = snake[0].y - snake[0].oldY;
  // limita la testa all'interno dei bordi
  const headPos = {
    x: Math.min(Math.max(snake[0].x + headDeltaX * t, padding / 2), cols - 1 - padding / 2),
    y: Math.min(Math.max(snake[0].y + headDeltaY * t, padding / 2), rows - 1 - padding / 2)
  };
  /*const headPos = {
	x: snake[0].x + (snake[0].x - snake[0].oldX) * t, 
	y: snake[0].y + (snake[0].y - snake[0].oldY) * t};*/
  const headDir = {
    x:(snake[0].x - snake[0].oldX), 
	y:(snake[0].y - snake[0].oldY)
  }
  drawHead(gameCtx, headPos, headDir, snake[0]);

  if (redrawStats) drawStatsArray(statsCtx, statsCanvas);


  //fps
  if(isFps) {
    fps = (1000 / delta) | 0;
    if (fps < minFps && fps > 2) minFps = fps;
    statsCtx.fillStyle = COLORS.white;
    statsCtx.font = `${Math.max(8, cell * 0.5)}px sans-serif`;
	statsCtx.textAlign = 'left';
	statsCtx.textBaseline = 'middle';
    statsCtx.fillText(`FPS: ${fps} - min: ${minFps}`, 2, 10);
    lastTime = timestamp;
  }

  if (message.length) {
    gameCtx.fillStyle = COLORS.white;
    gameCtx.font = `${Math.max(8, cell * 0.5)}px sans-serif`;
	gameCtx.textAlign = 'left';
	gameCtx.textBaseline = 'middle';
	const fiveSecondsAgo = Date.now() - 6000;
    message = message.filter(e => e.dat >= fiveSecondsAgo);
	let messages = message.map(e => e.msg).join(' - ');
	
	gameCtx.fillText('A:\\> ' + messages, 2, 10);	
  }


  requestAnimationFrame(gameLoop);
}

let fps = 0;
let isFps = false;
let minFps = 9999;



requestAnimationFrame(gameLoop);

function reset() {
  snake = [ { x: (cols / 3) | 0, 
			  y: (rows / 3) | 0, 
			  oldX: ((cols / 3) | 0) - 1, 
			  oldY: (rows / 3) | 0 } ];
  dir = { x: 1, y: 0 };
  apples = [];
  spawnObject(apples, 0);
  snakeMinLength = 4;
  
  bananaGrow = 0;
  poisonEffect = 0;
  skeletorFactor = 1;
  burgerFactor = 1;
  godmodeEffect = 0;
  eyelidEnabled = false;
  snakeEyesEnabled = false;
  
  let patternType = (Math.random() * 3)|0;
  initSnakePatterns(patternType);
  currentSnakePattern = 0;
  
  statsArray = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  applesEaten = [];
  
  inputQueue = [];
  message = [];
  
  alive = true;
  lastTime = performance.now();
  moveTimer = 0;

  requestAnimationFrame(gameLoop);
}


function addTouchSwipe(el, {threshold = 40, maxTime = 500, onSwipe} = {}) {
  let sx = 0, sy = 0, st = 0;

  el.addEventListener('touchstart', e => {
    const t = e.changedTouches[0];
    sx = t.clientX; sy = t.clientY; st = Date.now();
  }, {passive: true});

  el.addEventListener('touchend', e => {
    const t = e.changedTouches[0];
    const dx = t.clientX - sx;
    const dy = t.clientY - sy;
    const dt = Date.now() - st;
    if (dt > maxTime) return;
    if (Math.abs(dx) >= threshold || Math.abs(dy) >= threshold) {
      if (Math.abs(dx) > Math.abs(dy)) {
        onSwipe(dx > 0 ? 'right' : 'left', {dx, dy, dt});
      } else {
        onSwipe(dy > 0 ? 'down' : 'up', {dx, dy, dt});
      }
    }
  }, {passive: true});
}
addTouchSwipe(document.body, {
  threshold: 60,
  onSwipe: function(dir) {
    let newDir = null;
    if (dir === 'up')    newDir = {x: 0, y: -1};
    if (dir === 'down')  newDir = {x: 0, y: 1};
    if (dir === 'left')  newDir = {x: -1, y: 0};
    if (dir === 'right') newDir = {x: 1, y: 0};
    
    if (newDir) {
      const lastDir = inputQueue.length > 0 ? inputQueue[inputQueue.length - 1] : dir;
      //evita direzioni opposte o uguali
	  let isOpposite = newDir.x === -lastDir.x && newDir.y === -lastDir.y;
	  let isSame = newDir.x === lastDir.x && newDir.y === lastDir.y;
      if (!isOpposite && !isSame) {
        inputQueue.push(newDir);
        if (inputQueue.length > 30) inputQueue.shift();
      }
    }
  }
});

let isMute = true;
function playSound(id) {
  if (isMute) return;
  const audio = document.getElementById(id);
  if (audio) {
	audio.currentTime = 0;
	audio.play();
  }
}

</script>
</body>
</html>
